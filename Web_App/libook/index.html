<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.js"></script>
    <title>ISBNバーコード 静的解析（矩形ドラッグ式）</title>
    <style>
        body { margin: 0; padding: 0; }
        #container {
            position: relative;
            margin: 20px auto;
            width: 100vw;
            max-width: 100vw;
            touch-action: none;
        }
        #preview-area {
            position: relative;
            margin: 0 auto;
            width: 90vw;
            max-width: 600px;
            aspect-ratio: 4/3;
            background: #eee;
            overflow: hidden;
        }
        #canvas-capture {
            display: block;
            width: 100%;
            height: 100%;
            aspect-ratio: 4/3;
            background: #eee;
            position: absolute;
            left: 0; top: 0;
            z-index: 0;
        }
        #video-preview {
            display: block;
            width: 100%;
            height: 100%;
            aspect-ratio: 4/3;
            background: #eee;
            position: absolute;
            left: 0; top: 0;
            z-index: 0;
        }
        #crop-rect-svg {
            position: absolute;
            left: 0; top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .rect-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #fff;
            border: 3px solid #e33;
            border-radius: 50%;
            box-sizing: border-box;
            z-index: 20;
            touch-action: none;
            transform: translate(-12px, -12px);
        }
        #rect-move-area {
            position: absolute;
            border: 2px dashed #e33;
            background: rgba(255,0,0,0.06);
            z-index: 15;
            touch-action: none;
        }
        #cropped-barcode {
            display: block;
            margin: 18px auto 10px auto;
            border: 2px solid blue;
            width: 90vw;
            max-width: 600px;
            max-height: 240px;
            aspect-ratio: auto;
        }
        @media (max-width: 600px) {
            #preview-area, #cropped-barcode {
                max-width: 100vw;
                width: 100vw;
            }
            .rect-handle {
                width: 20px;
                height: 20px;
                transform: translate(-10px,-10px);
            }
        }
        button { margin: 5px 3px; }
    </style>
</head>
<body>
    <input type="text" id="isbn"><input type="submit" value="検索" onclick="search()">
    <div id="output"></div>
    <button onclick="startCamera()">カメラ起動</button>
    <button onclick="captureFrame()">キャプチャ</button>
    <button onclick="cropCapture()">切り取り＆解析</button>
    <div id="container">
        <div id="preview-area">
            <video id="video-preview" autoplay playsinline></video>
            <canvas id="canvas-capture" style="display:none;"></canvas>
            <svg id="crop-rect-svg" style="display:none;"></svg>
            <div id="rect-move-area" style="display:none;"></div>
            <!-- 4 draggable handles will be inserted dynamically -->
        </div>
    </div>
    <script>
        // Google Books API検索
        const isbn = document.getElementById("isbn");
        const output = document.getElementById("output");
        isbn.addEventListener("keydown", e => { if (e.key === "Enter") search(); });
        async function search() {
            const url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn.value}`;
            output.innerHTML = "検索中...";
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`レスポンスステータス: ${response.status}`);
                const result = await response.json();
                if (!result.items || !result.items.length) {
                    output.innerText = '書籍情報が見つかりません';
                    return;
                }
                let info = result.items[0].volumeInfo;
                let title = info.title || "";
                let image = info.imageLinks ? info.imageLinks.thumbnail : "";
                output.innerHTML = `${title}<br>${image ? `<img src="${image}" alt="title_image">` : ""}`;
            } catch (error) { output.innerText = error.message; }
        }

        // カメラ
        let videoStream = null;
        let videoElem = document.getElementById('video-preview');
        let videoNaturalWidth = 0;
        let videoNaturalHeight = 0;

        function startCamera() {
            if (videoStream) return;
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
                .then(stream => {
                    videoStream = stream;
                    videoElem.srcObject = stream;
                    videoElem.style.display = 'block';
                    videoElem.onloadedmetadata = function() {
                        videoNaturalWidth = videoElem.videoWidth;
                        videoNaturalHeight = videoElem.videoHeight;
                        const canvas = document.getElementById('canvas-capture');
                        canvas.width = videoNaturalWidth;
                        canvas.height = videoNaturalHeight;
                        setupRectCrop(canvas.width, canvas.height);
                        canvas.style.display = 'none';
                        videoElem.style.display = 'block';
                    }
                })
                .catch(err => {
                    alert("カメラにアクセスできません: " + err.message);
                });
        }

        function captureFrame() {
            if (!videoStream || !videoElem) {
                alert("カメラが起動していません");
                return;
            }
            const canvas = document.getElementById('canvas-capture');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(videoElem, 0, 0, canvas.width, canvas.height);
            videoElem.style.display = 'none';
            canvas.style.display = 'block';
            updateRectCrop();
        }

        // --- 矩形ドラッグ式 crop ---
        let rectHandles = [];
        let rectCrop = null; // {x, y, w, h}
        let draggingHandle = null; // 'tl', 'tr', 'br', 'bl'
        let draggingRect = false;
        let rectDragOffset = {x:0, y:0};

        function setupRectCrop(imgW, imgH) {
            // 初期値: 画像中央に200x100の矩形
            rectCrop = {
                x: Math.floor((imgW-200)/2),
                y: Math.floor((imgH-100)/2),
                w: 200,
                h: 100
            };
            removeRectHandles();
            createRectHandles();
            updateRectCrop();
        }

        function removeRectHandles() {
            rectHandles.forEach(h=>{
                if(h.parentNode) h.parentNode.removeChild(h);
            });
            rectHandles = [];
            let moveArea = document.getElementById('rect-move-area');
            if(moveArea) moveArea.style.display = 'none';
        }

        function createRectHandles() {
            const preview = document.getElementById('preview-area');
            const handlesPos = ['tl','tr','br','bl'];
            rectHandles = [];
            handlesPos.forEach(pos => {
                let h = document.createElement('div');
                h.className = 'rect-handle';
                h.dataset.pos = pos;
                preview.appendChild(h);
                rectHandles.push(h);
                h.addEventListener('pointerdown', handleRectHandleDown, {passive:false});
                h.addEventListener('touchstart', function(e){e.preventDefault();}, {passive:false});
            });
            // 移動用エリア
            let moveArea = document.getElementById('rect-move-area');
            moveArea.style.display = 'block';
            moveArea.addEventListener('pointerdown', handleRectMoveDown, {passive:false});
            moveArea.addEventListener('touchstart', function(e){e.preventDefault();}, {passive:false});
        }

        function handleRectHandleDown(e) {
            e.preventDefault();
            draggingHandle = e.target.dataset.pos;
            document.addEventListener('pointermove', handleRectHandleMove, {passive:false});
            document.addEventListener('pointerup', handleRectHandleUp, {passive:false});
        }

        function handleRectHandleMove(e) {
            const canvas = document.getElementById('canvas-capture');
            const preview = document.getElementById('preview-area');
            const previewRect = preview.getBoundingClientRect();
            const scaleX = canvas.width / previewRect.width;
            const scaleY = canvas.height / previewRect.height;
            let px = (e.clientX - previewRect.left) * scaleX;
            let py = (e.clientY - previewRect.top) * scaleY;

            let {x, y, w, h} = rectCrop;
            if (draggingHandle === 'tl') {
                let newX = Math.min(x + w - 10, Math.max(0, px));
                let newY = Math.min(y + h - 10, Math.max(0, py));
                w = (x + w) - newX;
                h = (y + h) - newY;
                x = newX;
                y = newY;
            } else if (draggingHandle === 'tr') {
                let newX = Math.max(x + 10, Math.min(canvas.width, px));
                let newY = Math.min(y + h - 10, Math.max(0, py));
                w = newX - x;
                h = (y + h) - newY;
                y = newY;
            } else if (draggingHandle === 'br') {
                let newX = Math.max(x + 10, Math.min(canvas.width, px));
                let newY = Math.max(y + 10, Math.min(canvas.height, py));
                w = newX - x;
                h = newY - y;
            } else if (draggingHandle === 'bl') {
                let newX = Math.min(x + w - 10, Math.max(0, px));
                let newY = Math.max(y + 10, Math.min(canvas.height, py));
                w = (x + w) - newX;
                h = newY - y;
                x = newX;
            }
            // 最小サイズ
            w = Math.max(10, w);
            h = Math.max(10, h);
            // 範囲制限
            x = Math.max(0, Math.min(canvas.width - w, x));
            y = Math.max(0, Math.min(canvas.height - h, y));
            rectCrop = {x, y, w, h};
            updateRectCrop();
        }

        function handleRectHandleUp(e) {
            draggingHandle = null;
            document.removeEventListener('pointermove', handleRectHandleMove);
            document.removeEventListener('pointerup', handleRectHandleUp);
        }

        function handleRectMoveDown(e) {
            e.preventDefault();
            draggingRect = true;
            const canvas = document.getElementById('canvas-capture');
            const preview = document.getElementById('preview-area');
            const previewRect = preview.getBoundingClientRect();
            const scaleX = canvas.width / previewRect.width;
            const scaleY = canvas.height / previewRect.height;
            let px = (e.clientX - previewRect.left) * scaleX;
            let py = (e.clientY - previewRect.top) * scaleY;
            rectDragOffset.x = px - rectCrop.x;
            rectDragOffset.y = py - rectCrop.y;
            document.addEventListener('pointermove', handleRectMoveMove, {passive:false});
            document.addEventListener('pointerup', handleRectMoveUp, {passive:false});
        }

        function handleRectMoveMove(e) {
            if(!draggingRect) return;
            const canvas = document.getElementById('canvas-capture');
            const preview = document.getElementById('preview-area');
            const previewRect = preview.getBoundingClientRect();
            const scaleX = canvas.width / previewRect.width;
            const scaleY = canvas.height / previewRect.height;
            let px = (e.clientX - previewRect.left) * scaleX;
            let py = (e.clientY - previewRect.top) * scaleY;

            let newX = px - rectDragOffset.x;
            let newY = py - rectDragOffset.y;
            // 範囲制限
            newX = Math.max(0, Math.min(canvas.width - rectCrop.w, newX));
            newY = Math.max(0, Math.min(canvas.height - rectCrop.h, newY));
            rectCrop.x = newX;
            rectCrop.y = newY;
            updateRectCrop();
        }

        function handleRectMoveUp(e) {
            draggingRect = false;
            document.removeEventListener('pointermove', handleRectMoveMove);
            document.removeEventListener('pointerup', handleRectMoveUp);
        }

        function updateRectCrop() {
            const canvas = document.getElementById('canvas-capture');
            const preview = document.getElementById('preview-area');
            const previewRect = preview.getBoundingClientRect();
            const scaleX = previewRect.width / canvas.width;
            const scaleY = previewRect.height / canvas.height;
            // SVG枠
            const svg = document.getElementById('crop-rect-svg');
            svg.style.display = 'block';
            svg.setAttribute('width', previewRect.width);
            svg.setAttribute('height', previewRect.height);
            svg.style.width = previewRect.width + 'px';
            svg.style.height = previewRect.height + 'px';
            svg.style.left = '0px';
            svg.style.top = '0px';
            let x1 = rectCrop.x * scaleX, y1 = rectCrop.y * scaleY;
            let x2 = (rectCrop.x + rectCrop.w) * scaleX, y2 = y1;
            let x3 = x2, y3 = (rectCrop.y + rectCrop.h) * scaleY;
            let x4 = x1, y4 = y3;
            svg.innerHTML = `<polygon points="${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}" style="fill:rgba(255,0,0,0.08);stroke:#e33;stroke-width:2"/>`;

            // ハンドル
            let handles = [
                [x1, y1], [x2, y2], [x3, y3], [x4, y4]
            ];
            rectHandles.forEach((h, i) => {
                h.style.left = handles[i][0] + 'px';
                h.style.top = handles[i][1] + 'px';
            });
            // 移動エリア
            const moveArea = document.getElementById('rect-move-area');
            moveArea.style.display = 'block';
            moveArea.style.left = x1 + 'px';
            moveArea.style.top = y1 + 'px';
            moveArea.style.width = (x3 - x1) + 'px';
            moveArea.style.height = (y3 - y1) + 'px';
        }

        // 切り取り＆解析
        function cropCapture() {
            const canvas = document.getElementById('canvas-capture');
            const ctx = canvas.getContext('2d');
            if(!rectCrop || rectCrop.w < 1 || rectCrop.h < 1) {
                alert('切り取り範囲が指定されていません。');
                return;
            }
            let cropX = Math.round(rectCrop.x);
            let cropY = Math.round(rectCrop.y);
            let cropW = Math.round(rectCrop.w);
            let cropH = Math.round(rectCrop.h);

            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = cropW;
            cropCanvas.height = cropH;
            const cropCtx = cropCanvas.getContext('2d');
            cropCtx.putImageData(ctx.getImageData(cropX, cropY, cropW, cropH), 0, 0);

            let old = document.getElementById('cropped-barcode');
            if (old) old.remove();
            cropCanvas.id = 'cropped-barcode';
            cropCanvas.style.display = 'block';
            cropCanvas.style.margin = '10px auto';
            cropCanvas.style.border = '2px solid blue';
            document.body.appendChild(cropCanvas);

            Quagga.decodeSingle({
                src: cropCanvas.toDataURL(),
                inputStream: {
                    size: Math.max(cropW, cropH)
                },
                locator: { patchSize: "medium", halfSample: true },
                decoder: { readers: ["ean_reader", "upc_reader"] }
            }, function(result) {
                if (result && result.codeResult && result.codeResult.code) {
                    isbn.value = result.codeResult.code;
                    search();
                } else {
                    alert("解析失敗。consoleを確認してください。");
                    console.log("decodeSingle failed", result);
                }
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas-capture');
            let w = 800, h = 600;
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            setupRectCrop(w, h);
            updateRectCrop();
        });
        window.addEventListener('resize', updateRectCrop);
    </script>
</body>
</html>