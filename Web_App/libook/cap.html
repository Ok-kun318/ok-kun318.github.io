<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ISBNバーコード 静的解析（矩形ドラッグ式・完全新規）</title>
  <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.js"></script>
  <style>
    body { margin: 0; padding: 0; background: #f8f8f8; }
    #container {
      position: relative;
      margin: 16px auto;
      width: 96vw;
      max-width: 640px;
      touch-action: none;
    }
    #preview-area {
      position: relative;
      margin: 0 auto;
      width: 100%;
      aspect-ratio: 4/3;
      background: #eee;
      overflow: hidden;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    }
    #video-preview, #canvas-capture {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      aspect-ratio: 4/3;
      background: #eee;
      object-fit: cover;
      border-radius: 6px;
      z-index: 0;
    }
    #canvas-capture { display: none; }
    #crop-rect-svg {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    .rect-handle {
      position: absolute;
      width: 22px;
      height: 22px;
      background: #fff;
      border: 3px solid #e33;
      border-radius: 50%;
      box-sizing: border-box;
      z-index: 20;
      touch-action: none;
      transform: translate(-11px, -11px);
      box-shadow: 0 0 3px #aaa;
    }
    #rect-move-area {
      position: absolute;
      border: 2px dashed #e33;
      background: rgba(255,0,0,.07);
      z-index: 15;
      touch-action: none;
      cursor: move;
      border-radius: 2px;
    }
    #cropped-barcode {
      display: block;
      margin: 18px auto 10px auto;
      border: 2px solid #2196f3;
      width: 96vw;
      max-width: 640px;
      max-height: 220px;
      aspect-ratio: auto;
      border-radius: 6px;
    }
    @media (max-width: 600px) {
      #preview-area, #cropped-barcode {
        max-width: 100vw;
        width: 100vw;
      }
      .rect-handle {
        width: 18px;
        height: 18px;
        transform: translate(-9px,-9px);
      }
    }
    button { margin: 8px 6px; }
    #output {
      padding: 6px 0 16px 0;
      min-height: 2em;
    }
  </style>
</head>
<body>
  <input type="text" id="isbn"><input type="submit" value="検索" onclick="search()">
  <div id="output"></div>
  <button onclick="startCamera()">カメラ起動</button>
  <button onclick="captureFrame()">キャプチャ</button>
  <button onclick="cropCapture()">切り取り＆解析</button>
  <div id="container">
    <div id="preview-area">
      <video id="video-preview" autoplay playsinline></video>
      <canvas id="canvas-capture"></canvas>
      <svg id="crop-rect-svg"></svg>
      <div id="rect-move-area"></div>
      <!-- 4 draggable handles will be inserted dynamically -->
    </div>
  </div>
  <script>
    // Google Books API検索
    const isbn = document.getElementById("isbn");
    const output = document.getElementById("output");
    isbn.addEventListener("keydown", e => { if (e.key === "Enter") search(); });
    async function search() {
      const url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn.value}`;
      output.innerHTML = "検索中...";
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`レスポンスステータス: ${response.status}`);
        const result = await response.json();
        if (!result.items || !result.items.length) {
          output.innerText = '書籍情報が見つかりません';
          return;
        }
        let info = result.items[0].volumeInfo;
        let title = info.title || "";
        let image = info.imageLinks ? info.imageLinks.thumbnail : "";
        output.innerHTML = `${title}<br>${image ? `<img src="${image}" alt="title_image">` : ""}`;
      } catch (error) { output.innerText = error.message; }
    }

    // カメラ・キャプチャ
    let videoStream = null;
    let videoElem = document.getElementById('video-preview');
    let videoNaturalWidth = 0;
    let videoNaturalHeight = 0;

    function startCamera() {
      if (videoStream) return;
      navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
        .then(stream => {
          videoStream = stream;
          videoElem.srcObject = stream;
          videoElem.style.display = 'block';
          videoElem.onloadedmetadata = function() {
            videoNaturalWidth = videoElem.videoWidth;
            videoNaturalHeight = videoElem.videoHeight;
            const canvas = document.getElementById('canvas-capture');
            canvas.width = videoNaturalWidth;
            canvas.height = videoNaturalHeight;
            canvas.style.display = 'none';
            videoElem.style.display = 'block';
            setupRectCrop(canvas.width, canvas.height);
            updateRectCrop();
          }
        })
        .catch(err => {
          alert("カメラにアクセスできません: " + err.message);
        });
    }

    function captureFrame() {
      if (!videoStream || !videoElem) {
        alert("カメラが起動していません");
        return;
      }
      const canvas = document.getElementById('canvas-capture');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(videoElem, 0, 0, canvas.width, canvas.height);
      videoElem.style.display = 'none';
      canvas.style.display = 'block';
      updateRectCrop();
    }

    // --- 矩形ドラッグ式 crop ---
    let rectHandles = [];
    let rectCrop = null; // {x, y, w, h}
    let draggingHandle = null; // 'tl', 'tr', 'br', 'bl'
    let draggingRect = false;
    let rectDragOffset = {x:0, y:0};

    function setupRectCrop(imgW, imgH) {
      rectCrop = {
        x: Math.floor((imgW-200)/2),
        y: Math.floor((imgH-100)/2),
        w: 200,
        h: 100
      };
      removeRectHandles();
      createRectHandles();
      updateRectCrop();
    }

    function removeRectHandles() {
      rectHandles.forEach(h=>{
        if(h.parentNode) h.parentNode.removeChild(h);
      });
      rectHandles = [];
      let moveArea = document.getElementById('rect-move-area');
      if(moveArea) moveArea.style.display = 'none';
    }

    function createRectHandles() {
      const preview = document.getElementById('preview-area');
      const handlesPos = ['tl','tr','br','bl'];
      rectHandles = [];
      handlesPos.forEach(pos => {
        let h = document.createElement('div');
        h.className = 'rect-handle';
        h.dataset.pos = pos;
        preview.appendChild(h);
        rectHandles.push(h);
        h.addEventListener('pointerdown', handleRectHandleDown, {passive:false});
        h.addEventListener('touchstart', function(e){e.preventDefault();}, {passive:false});
      });
      // 移動用エリア
      let moveArea = document.getElementById('rect-move-area');
      moveArea.style.display = 'block';
      moveArea.addEventListener('pointerdown', handleRectMoveDown, {passive:false});
      moveArea.addEventListener('touchstart', function(e){e.preventDefault();}, {passive:false});
    }

    function handleRectHandleDown(e) {
      e.preventDefault();
      draggingHandle = e.target.dataset.pos;
      document.addEventListener('pointermove', handleRectHandleMove, {passive:false});
      document.addEventListener('pointerup', handleRectHandleUp, {passive:false});
    }

    function handleRectHandleMove(e) {
      const canvas = document.getElementById('canvas-capture');
      const preview = document.getElementById('preview-area');
      const previewRect = preview.getBoundingClientRect();
      const scaleX = canvas.width / previewRect.width;
      const scaleY = canvas.height / previewRect.height;
      let px = (e.clientX - previewRect.left) * scaleX;
      let py = (e.clientY - previewRect.top) * scaleY;

      let {x, y, w, h} = rectCrop;
      if (draggingHandle === 'tl') {
        let newX = Math.min(x + w - 10, Math.max(0, px));
        let newY = Math.min(y + h - 10, Math.max(0, py));
        w = (x + w) - newX;
        h = (y + h) - newY;
        x = newX;
        y = newY;
      } else if (draggingHandle === 'tr') {
        let newX = Math.max(x + 10, Math.min(canvas.width, px));
        let newY = Math.min(y + h - 10, Math.max(0, py));
        w = newX - x;
        h = (y + h) - newY;
        y = newY;
      } else if (draggingHandle === 'br') {
        let newX = Math.max(x + 10, Math.min(canvas.width, px));
        let newY = Math.max(y + 10, Math.min(canvas.height, py));
        w = newX - x;
        h = newY - y;
      } else if (draggingHandle === 'bl') {
        let newX = Math.min(x + w - 10, Math.max(0, px));
        let newY = Math.max(y + 10, Math.min(canvas.height, py));
        w = (x + w) - newX;
        h = newY - y;
        x = newX;
      }
      w = Math.max(10, w);
      h = Math.max(10, h);
      x = Math.max(0, Math.min(canvas.width - w, x));
      y = Math.max(0, Math.min(canvas.height - h, y));
      rectCrop = {x, y, w, h};
      updateRectCrop();
    }

    function handleRectHandleUp(e) {
      draggingHandle = null;
      document.removeEventListener('pointermove', handleRectHandleMove);
      document.removeEventListener('pointerup', handleRectHandleUp);
    }

    function handleRectMoveDown(e) {
      e.preventDefault();
      draggingRect = true;
      const canvas = document.getElementById('canvas-capture');
      const preview = document.getElementById('preview-area');
      const previewRect = preview.getBoundingClientRect();
      const scaleX = canvas.width / previewRect.width;
      const scaleY = canvas.height / previewRect.height;
      let px = (e.clientX - previewRect.left) * scaleX;
      let py = (e.clientY - previewRect.top) * scaleY;
      rectDragOffset.x = px - rectCrop.x;
      rectDragOffset.y = py - rectCrop.y;
      document.addEventListener('pointermove', handleRectMoveMove, {passive:false});
      document.addEventListener('pointerup', handleRectMoveUp, {passive:false});
    }

    function handleRectMoveMove(e) {
      if(!draggingRect) return;
      const canvas = document.getElementById('canvas-capture');
      const preview = document.getElementById('preview-area');
      const previewRect = preview.getBoundingClientRect();
      const scaleX = canvas.width / previewRect.width;
      const scaleY = canvas.height / previewRect.height;
      let px = (e.clientX - previewRect.left) * scaleX;
      let py = (e.clientY - previewRect.top) * scaleY;
      let newX = px - rectDragOffset.x;
      let newY = py - rectDragOffset.y;
      newX = Math.max(0, Math.min(canvas.width - rectCrop.w, newX));
      newY = Math.max(0, Math.min(canvas.height - rectCrop.h, newY));
      rectCrop.x = newX;
      rectCrop.y = newY;
      updateRectCrop();
    }

    function handleRectMoveUp(e) {
      draggingRect = false;
      document.removeEventListener('pointermove', handleRectMoveMove);
      document.removeEventListener('pointerup', handleRectMoveUp);
    }

    function updateRectCrop() {
      const canvas = document.getElementById('canvas-capture');
      const preview = document.getElementById('preview-area');
      const previewRect = preview.getBoundingClientRect();
      const scaleX = previewRect.width / canvas.width;
      const scaleY = previewRect.height / canvas.height;
      // SVG枠
      const svg = document.getElementById('crop-rect-svg');
      svg.style.display = 'block';
      svg.setAttribute('width', previewRect.width);
      svg.setAttribute('height', previewRect.height);
      svg.style.width = previewRect.width + 'px';
      svg.style.height = previewRect.height + 'px';
      svg.style.left = '0px';
      svg.style.top = '0px';
      let x1 = rectCrop.x * scaleX, y1 = rectCrop.y * scaleY;
      let x2 = (rectCrop.x + rectCrop.w) * scaleX, y2 = y1;
      let x3 = x2, y3 = (rectCrop.y + rectCrop.h) * scaleY;
      let x4 = x1, y4 = y3;
      svg.innerHTML = `<polygon points="${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}" style="fill:rgba(255,0,0,0.08);stroke:#e33;stroke-width:2"/>`;

      // ハンドル
      let handles = [
        [x1, y1], [x2, y2], [x3, y3], [x4, y4]
      ];
      rectHandles.forEach((h, i) => {
        h.style.left = handles[i][0] + 'px';
        h.style.top = handles[i][1] + 'px';
      });
      // 移動エリア
      const moveArea = document.getElementById('rect-move-area');
      moveArea.style.display = 'block';
      moveArea.style.left = x1 + 'px';
      moveArea.style.top = y1 + 'px';
      moveArea.style.width = (x3 - x1) + 'px';
      moveArea.style.height = (y3 - y1) + 'px';
    }

    // 切り取り＆解析
    function cropCapture() {
      const canvas = document.getElementById('canvas-capture');
      const ctx = canvas.getContext('2d');
      if(!rectCrop || rectCrop.w < 1 || rectCrop.h < 1) {
        alert('切り取り範囲が指定されていません。');
        return;
      }
      let cropX = Math.round(rectCrop.x);
      let cropY = Math.round(rectCrop.y);
      let cropW = Math.round(rectCrop.w);
      let cropH = Math.round(rectCrop.h);

      if (cropX < 0 || cropY < 0 || cropX + cropW > canvas.width || cropY + cropH > canvas.height) {
        alert("切り取り範囲が画像外です");
        return;
      }

      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = cropW;
      cropCanvas.height = cropH;
      const cropCtx = cropCanvas.getContext('2d');
      cropCtx.putImageData(ctx.getImageData(cropX, cropY, cropW, cropH), 0, 0);

      let old = document.getElementById('cropped-barcode');
      if (old) old.remove();
      cropCanvas.id = 'cropped-barcode';
      cropCanvas.style.display = 'block';
      cropCanvas.style.margin = '10px auto';
      cropCanvas.style.border = '2px solid #2196f3';
      document.body.appendChild(cropCanvas);

      Quagga.decodeSingle({
        src: cropCanvas.toDataURL(),
        inputStream: {
          size: Math.max(cropW, cropH)
        },
        locator: { patchSize: "medium", halfSample: true },
        decoder: { readers: ["ean_reader", "upc_reader"] }
      }, function(result) {
        if (result && result.codeResult && result.codeResult.code) {
          isbn.value = result.codeResult.code;
          search();
        } else {
          alert("解析失敗。consoleを確認してください。");
          console.log("decodeSingle failed", result);
        }
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('canvas-capture');
      let w = 800, h = 600;
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      setupRectCrop(w, h);
      updateRectCrop();
    });
    window.addEventListener('resize', updateRectCrop);
  </script>
</body>
</html>